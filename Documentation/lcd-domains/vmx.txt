
==============================
OVERVIEW
==============================

This code is in arch/x86/lcd-domains/ and 
arch/x86/include/asm/lcd-domains-arch.h.

The two main objects are struct lcd_arch and struct lcd_arch_thread, defined in
arch/x86/include/asm/lcd-domains-arch.h.

struct lcd_arch contains the extended page table (EPT) guest physical address
space information, and a list of the contained lcd_arch_thread's.

struct lcd_arch_thread corresponds with an Intel VT-x virtual machine, and
contains all state needed to manage it. Each lcd_arch_thread uses the EPT of
its parent lcd_arch.

See the comments in the header lcd-domains-arch.h (above), and the test
cases in arch/x86/lcd-domains/lcd-domains-arch-tests.c.

========================================
EXAMPLE
========================================

Here is an example how to set up one lcd_arch with one lcd_arch_thread, and
run it (without the error checking).


struct lcd_arch *lcd_arch;
struct lcd_arch_thread *lcd_arch_thread;

/*
 * Create the lcd_arch
 */
lcd_arch = lcd_arch_create();

/* (...Allocate and map pages in the LCD...) */

/*
 * Create and add a thread
 */
lcd_arch_thread = lcd_arch_add_thread(lcd_arch);

/* (...Set up the thread's program counter, etc...) */

/*
 * Tear down the thread
 */
lcd_arch_destroy_thread(lcd_arch_thread);

/*
 * Tear down the LCD
 */
lcd_arch_destroy(lcd_arch);


========================================
ADDRESS SPACES
========================================

One of the hardest, error-prone, confusing parts of this is we need to keep
track of four different kinds of addresses:

   (1) host physical
   (2) host virtual
   (3) guest physical
   (4) guest virtual

We have created four different data types (much like those used for
page tables -- pte_t, pmd_t, ...):

   (1) host physical    hpa_t
   (2) host virtual     hva_t
   (3) guest physical   gpa_t
   (4) guest virtual    gva_t

and routines for converting between them. Some conversions are not supported
directly, and must be done with more work -- e.g., guest physical to host
virtual requires an EPT. But some, like host physical to host virtual, can
be done using host macros. See the arch header.

Host physical addresses need to be stored in the EPT.

Guest physical addresses need to be stored in the guest virtual page tables.

==============================
LOCKING
==============================

TODO: Some of the arch code is not thread safe.

Locks are used on an lcd_arch's ept and its list of lcd_arch_threads.

We use mutexes for now, so some functions are not safe to call from
interrupt context (we can sleep when we lock a mutex).

This makes debugging easier since we can interrupt locks (no deadlocks).

==============================
GDT/TSS/IDT
==============================

We will need GDT/TSS/IDT in the future when we provide full support for running
multiple threads inside an LCD, and if those threads are handling some
exceptions/interrupts (like guest virtual page faults).

When an LCD thread is spawned, the creator should provide 4 pages of memory:

     -- 1 for thread's stack/utcb
     -- 1 for its gdt
     -- 1 for its tss
     -- 1 for its idt

The IDT/GDT could be shared by threads, but it might be complicated, and the
microkernel would have to make certain assumptions or enforce certain polices
to protect itself (e.g., if it needed to modify the IDT/GDT when setting up
a new thread). Having a TSS per thread makes some sense - a thread here is more
like a logical core - and this is what Linux does.

I'm putting the gdt / tss init code here for reference since it was quite
complicated to do (some of the macros won't be relevant anymore):

	/*
	 * Alloc zero'd page for gdt
	 */
	lcd->gdt = (struct desc_struct *)get_zeroed_page(GFP_KERNEL);
	if (!lcd->gdt) {
		printk(KERN_ERR "vmx init gdt: failed to alloc gdt\n");
		ret = -ENOMEM;
		goto fail;
	}

	/*
	 *===--- Populate gdt; see layout in lcd-domains-arch.h. ---===
	 */

	/*
	 * Code Segment
	 */
	desc = lcd->gdt + (LCD_ARCH_CS_SELECTOR >> 3); /* div by 8 */
	vmx_pack_desc(desc,
		0,        /* base */
		0xFFFFF,  /* limit (granularity = 1) */
		0xB,      /* code seg type, exec/read/accessed */
		0x1,      /* code/data segment desc type */
		0x0,      /* dpl = 0 */
		0x1,      /* present */
		0x0,      /* avl (not used) */
		0x1,      /* 64-bit code */
		0x0,      /* d must be cleared for 64-bit code */
		0x1);     /* 4KB granularity */

	/*
	 * Data Segment (for %fs)
	 */
	desc = lcd->gdt + (LCD_ARCH_FS_SELECTOR >> 3); /* div by 8 */
	vmx_pack_desc(desc,
		0,        /* base */
		0xFFFFF,  /* limit (granularity = 1) */
		0x3,      /* data seg type, exec/read/accessed */
		0x1,      /* code/data segment desc type */
		0x0,      /* dpl = 0 */
		0x1,      /* present */
		0x0,      /* avl (not used) */
		0x0,      /* l (not 64-bit code) */
		0x1,      /* d (linux uses 1 for d ...) */
		0x1);     /* 4KB granularity */

	/*
	 * Data Segment (for %gs)
	 */
	desc = lcd->gdt + (LCD_ARCH_GS_SELECTOR >> 3); /* div by 8 */
	vmx_pack_desc(desc,
		0,        /* base */
		0xFFFFF,  /* limit (granularity = 1) */
		0x3,      /* data seg type, exec/read/accessed */
		0x1,      /* code/data segment desc type */
		0x0,      /* dpl = 0 */
		0x1,      /* present */
		0x0,      /* avl (not used) */
		0x0,      /* l (not 64-bit code) */
		0x1,      /* d (linux uses 1 for d ...) */
		0x1);     /* 4KB granularity */

	/*
	 * Task Segment (descriptor)
	 */
	tssd = (struct tss_desc *)(lcd->gdt + (LCD_ARCH_TR_SELECTOR >> 3));
	set_tssldt_descriptor(tssd, 
			gpa_val(LCD_ARCH_TSS_BASE),/* base */
			0xB,                       /* type = 64-bit busy tss */
			LCD_ARCH_TSS_LIMIT);       /* limit */

	/*
	 *===--- Map GDT in guest physical address space ---===
	 */
	ret = lcd_arch_ept_map(lcd, 
			/* gpa */
			LCD_ARCH_GDTR_BASE, 
			/* hpa */
			va2hpa(lcd->gdt),
			/* create paging structs as needed */
			1,
			/* no overwrite */
			0);

       ======================================= END GDT CODE

	/*
	 * Alloc zero'd page for tss.
	 *
	 * Only the first part of the page will be filled by the tss. This is
	 * done for now to make the address space layout simpler, but
	 * could perhaps be improved later.
	 */
	lcd->tss = (struct lcd_arch_tss *)get_zeroed_page(GFP_KERNEL);
	if (!lcd->tss) {
		printk(KERN_ERR "vmx_init_tss: failed to alloc tss\n");
		ret = -ENOMEM;
		goto fail;
	}
	base_tss = &(lcd->tss->base_tss);
	/*
	 * Set up 64-bit TSS (See Intel SDM V3 7.7)
	 *
	 * XXX: No interrupt stack tables are used (since the lcd won't be
	 * handling interrupts for now).
	 *
	 * Privilege Level 0 Stack
	 *
	 * XXX: This should be moved to arch-dep interface code, so
	 * that arch-indep code can set it. Relies on arch-indep
	 * code to use gva = gpa!
	 */
	base_tss->sp0 = gpa_val(LCD_ARCH_STACK_TOP);
	/*
	 * The TSS must have a minimal I/O bitmap with one byte of 1's
	 *
	 * Intel SDM V1 16.5.2
	 */
	base_tss->io_bitmap_base = offsetof(struct lcd_arch_tss, io_bitmap);
	vcpu->tss->io_bitmap[0] = 0xff;

	/*
	 *===--- Map TSS in guest physical address space ---===
	 */
	ret = lcd_arch_ept_map(vcpu, 
			/* gpa */
			LCD_ARCH_TSS_BASE, 
			/* hpa */
			va2hpa(vcpu->tss),
			/* create paging structs as needed */
			1,
			/* no overwrite */
			0);

