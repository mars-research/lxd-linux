
========================================
OVERVIEW
========================================

This code is in virt/lcd-domains and include/lcd-domains. It is the
arch-independent layer of the LCD microkernel.

The two main objects are struct lcd and struct lcd_thread, defined in
include/lcd-domains/lcd-domains.h.

struct lcd contains the guest physical address space (in 
underlying lcd_arch), and a list of lcd_thread's. It will soon contain
the lcd's cspace when that is incorporated.

struct lcd_thread corresponds with a host kernel thread that is running
inside the hardware virtual machine. It contains a pointer to the thread's
utcb (for easy microkernel access), and a pointer to the underlying
lcd_arch_thread (the hardware vm).

Why have one kernel thread / hardware vm for each lcd_thread? Answer: To keep
the microkernel simple. The microkernel could add an additional layer of
virtualization on top of the hardware vm, so that we didn't have so many
hardware vm's floating around. But it would be complicated and we would then 
have to write scheduler code in the microkernel.

A struct lcd is created by providing a module name. The module will be loaded
inside the lcd, and an initial lcd_thread will be created (stored in the
struct lcd's init_thread field) that, when started, will execute the module's
init code.

See also the comments in the header lcd-domains.h (above) and the test cases
in virt/lcd-domains/lcd-tests.c.

========================================
SETUP
========================================

Aside from building and installing the kernel code, you will need to do one
extra step, explained in detail below.

Background
----------

We don't want tricky logic for locating modules, so we want to re-use the
request_module facility in the kernel. But this relies on the user space
modprobe tools. So, we did the following:

   -- we modified the module loading code in the kernel so that a caller
      can safely load a module that is destined for an lcd in the host
      (modules destined for an lcd *will not* have their init code executed
      when installed in the host, nor their exit code executed when they
      are uninstalled from the host)
   -- we added an ioctl interface that user code can use to
      load a module destined for an lcd; it uses the patched module loading
      code
   -- we created a patched modprobe that uses this interface
   -- we patched request_module to allow kernel code to load a module
      destined for an lcd, using the patched modprobe

So, when you call lcd_create, the kernel loads the module using the patched
modprobe.

This means you need to have the patched modprobe properly installed!

Step 1
------

Build and install the kernel and all modules. In the root directory of the
kernel source,

    [ 1 ] make menuconfig

            -- go into Virtualization (2) and select Lightweight Capability
               Domains and Intel Support for LCDs
            -- it is recommended you build them as modules, for debugging

    [ 2 ] exit and save the configuration

    [ 3 ] make

            -- use make -j 8 if e.g. you have 8 cores, will go faster

    [ 4 ] sudo make modules_install install

            -- order is important!
            -- this should automatically update the grub boot menu


Step 2 - Patched Modprobe Setup
-------------------------------

The patched version is inside tools/module-init-tools.

To build and install, enter the module-init-tools directory,
and do the following:

       [ 1 ] aclocal -I m4 && automake --add-missing --copy && autoconf

       [ 2 ] ./configure --prefix=/ --program-prefix=lcd-

       [ 3 ] make

       [ 4 ] (sudo) make install

This will install the patched /sbin/lcd-modprobe and /sbin/lcd-insmod,
as well as the other init tools that were left untouched. The
request_module will use lcd-modprobe to load the module.

The man pages won't install on emulab (since /share is read only).
You can specify a different man dir via configure if you wish.

[Note: The only changes to init tools are in modprobe.c and insmod.c; only
the changes in modprobe.c are of interest (lcd-insmod is not currently
used/needed). Instead of doing the Linux init_module system call,
lcd-modprobe does an ioctl call to the LCD driver (hence, the LCD driver
must be loaded), with the bytes of the module, its size, and command
line options.]


Step 3 - Reboot and install
---------------------------

After rebooting the machine, select the new kernel to boot it.

After booting, if you built the lcd system as modules, do:

        [ 1 ] insmod ${MODULE_PATH}/arch/x86/lcd-domains/lcd-domains-arch.ko

        [ 2 ] insmod ${MODULE_PATH}/virt/lcd-domains/lcd-domains.ko

where ${MODULE_PATH} is something like /lib/modules/3.10.14/kernel.

This will install the lcd system.

You can now create an lcd using the example below.


========================================
EXAMPLE
========================================

Here is an example of how to start up an lcd with a module named foo.ko. foo.ko
should already be compiled and installed in the system's module load path.


struct lcd *lcd;
struct lcd_thread *lcd_thread;
int ret;

/*
 * Create the lcd
 */
ret = lcd_create("foo.ko", &lcd);

/*
 * Start the lcd's init thread (will run foo.ko's init routine)
 */
ret = lcd_thread_start(lcd->init_thread);

/* (...wait for a while, maybe sleep...) */

/*
 * Kill the init thread
 */
ret = lcd_thread_kill(lcd->init_thread);

/*
 * Tear down the LCD
 */
lcd_destroy(lcd);

========================================
MODULE LOADING
========================================

This one is a real zinger.



========================================
GUEST VIRTUAL ADDRESS SPACE
========================================

A good chunk of the current arch-independent code is for setting up the
boot guest virtual address space for an lcd. We assume that the lcd will take
over managing this, so we've kept allocation logic dirt simple.

Note that the microkernel is protected from what the lcd does to its guest
virtual address space. The microkernel manages the lcd's guest physical
address space, and the host pages the lcd has access to, so it can safely
write to memory without causing a page fault.


