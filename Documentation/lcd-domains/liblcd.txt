
========================================
OVERVIEW
========================================

This is the minimal libkernel that should be linked with an LCD. Right now,
it contains code for ipc, kmalloc, and page alloc, but requires whoever
boots the LCD to do some proper boot setup. See the example in
test-mods/mm.

========================================
BUILDING IT
========================================

The code is in liblcd/ and is built before we recursively descend into the
other directories. This is so we don't have 10 different recursive make's
trying to build the code and link it into lib.a (from the dependees
in the test-mods folders). I slightly tweaked the top-level Makefile to do
this.

I also slightly tweaked module building to allow for linking libraries with
modules. Most of the time, the build and link just worked, but occasionally, 
liblcd was listed first in the command to LD, and hence wasn't linked with the 
rest of the objects. (Recall that if a library is listed at the beginning
of the list of files to link with LD, it won't get linked with any of the
files, since there are no outstanding dependencies that require it.)

========================================
USING IT
========================================

See the examples in test-mods/. You should include the following three headers
in every source file for a module that will go inside an LCD:

    <lcd-domains/liblcd-config.h>

    ... other headers ...

    <lcd-domains/liblcd.h>
    <lcd-domains/liblcd-hacks.h>   /* recommended */

You should also list liblcd as a dependency in the Makefile. Again, see
the examples.

** You may need to do some extra work, see NOTES & SUGGESTIONS. **

IMPORTANT: Do not put liblcd-hacks.h inside header files. Here's a problematic
example:

file.h:

    #include <lcd-domains/liblcd-config.h>    /* GOOD */
    #include <linux/mm.h>
    #include <linux/types.h>
    #include <lcd-domains/liblcd-hacks.h>     /* BAD  */


    #define FOO(x) x

    static inline int bar(int x) { return x; }

    typedef unsigned long gfp_t;  /* this will break in file.c */

file.c

    #include <lcd-domains/liblcd-config.h>   /* GOOD    */
    #include "file.h"                        /* <<< BAD */
    #include <linux/gfp.h>  /* you will get a redefine error */   

The hacks header file can also undefine symbols that other host kernel
headers are expecting. So, to be safe, only put it in source code (.c) files
after *all* of the other headers.

========================================
HOW IT WORKS
========================================

I will explain by example.

Suppose you want to pull the function foo into liblcd, but you don't want
to reimplement it (imagine foo is something complicated like kmalloc).

First, you figure out that foo is declared in include/linux/foo.h and
defined in mm/foo.c. The first step is to make a copy of foo.c and put it
in liblcd/mm (I use the same directory structure as the kernel).

foo uses a lot of conditional compilation (using CONFIG_* macros), and you
want it to build in a certain way. Define or undefine the correct CONFIG_*
macros in liblcd-config.h, and put <lcd-domains/liblcd-config.h> at the
top of foo.c. This will make all of the code in foo.c and the headers it
includes have the proper configuration.

foo has a number of dependencies. There are five possible types for kernel
code:

   1 -- foo calls another function in foo.c
   2 -- foo calls another function in a different file that *is not* exported
   3 -- foo calls another function in a different file that *is* exported
   4 -- foo calls an inline function in a header it includes
   5 -- foo uses a macro defined in one of the headers it includes

The strategy depends on the type and how much complexity you want to
avoid:

  1
-----

Suppose foo calls bar, and bar is in foo.c. The call to bar will work, but
you will need to ensure all of bar's dependencies are fulfilled.

  2
-----

Suppose foo calls bar in bar.c. You have to resolve this dependency or
else linking will fail. You can pull in bar.c into liblcd, or you can
emulate bar in <lcd-domains/hacks.h>, either by eliding it away or
emulating it with other functions that are in liblcd. Pulling in bar.c
may be more complicated, but preferrable if other code depends on it and
bar isn't too complicated. Other functions in bar.c may not be needed, and
you can fulfill their dependencies with some major hacks and elision.

  3
-----

Suppose foo calls bar in bar.c. First, bar may never be called for your
scenarios, and if this is the case, it's probably best to elide it by putting
a hack in <lcd-domains/hacks.h>. Alternatively, you can suck in the file
bar.c. <lcd-domains/hacks.h> will elide the EXPORT_SYMBOL macros, so the
build system won't get confused when it sees a double export. Finally, you
can also choose not to resolve this dependency at all - if bar.c is
built for the host kernel, the build system will see that bar is exported,
and it won't complain when it tries to build and link foo.c in a library
or module (it will assume the dependency will be resolved when the module
is installed). Of course, if bar happens to be called unexpectedly inside
the LCD, you would probably get a page fault since bar is not linked.

Except for the lcd/ subdirectory, all of the source code is from the original
kernel, with very few changes (some files just have the two headers added -
liblcd-config.h and liblcd-hacks.h).

liblcd-config.h changes the build configuration so that the code will be
built for a uniprocessor machine with one NUMA node, no debugging, etc. This
was set up until I got it working; it may not be fully correct or work in
all build scenarios.

  4,5
-------

For macros and inlines, if they don't cause trouble, you don't have to do 
anything. But if they contain code that will break things, you're only option 
is to #undef them and emulate them in the hacks header.

Your goal is to make as few changes as possible - the more changes you make,
the easier it is to introduce bugs. You'll notice in liblcd/mm/slab.c,
I carefully mark where I made changes using /* BEGIN LCD */ and /* END LCD */.

========================================
NOTES & SUGGESTIONS
========================================

** IMPORTANT: If you have global variables that are uninitialized (in the
BSS section), you will need to manually zero them out at some point before
they are used in the LCD. You can see what those variables are by doing
something like

    nm my-module.ko | grep '.* b '
    nm my-module.ko | grep '.* B '

Some variables marked as __initdata do not show up as b or B via nm. I am
not sure if these are properly zero'd or not, so beware (I'm zero'ing 
some out to be safe). You can see all of the symbols using:

   readelf -s my-module.ko

You will see lines like this:

   82: 0000000000000000   360 OBJECT  LOCAL  DEFAULT   19 init_kmem_cache_node

This says init_kmem_cache_node is a local variable that resides in section
19. To list all sections, do:

   readelf -S my-module.ko

You will see lines like this (this is section 19):

  [19] .init.data        PROGBITS         0000000000000000  0000a3a0
       0000000000000168  0000000000000000  WA       0     0     32

Note that init_kmem_cache_node is marked as __initdata, so it appears in this
section.

====

While sucking in code into liblcd, you can build it and then see what
symbols are unresolved via nm. To be safe, you should go through every
line of the source code to see what the dependencies are, so that you 
are using the macros/inlines/etc. that you expect.

When linking with a module, you can make sure all dependencies are resolved
by running nm on it, e.g.,
  
    nm my-module.ko

This is after my-module.ko has been built and linked with liblcd/lib.a.

====

If you get page faults, you can look at the kernel logs to see where the
module was loaded in the host. Take the faulting address, and subtract off
the starting address of the core code that was loaded. Now objdump the
kernel module, and locate the address in there.

For example, if the faulting address was 0x1234, and the module was loaded
at address 0x1200, the offset into the module is 0x1234 - 0x1200 = 0x34.
Do:

    objdump -d my-module.ko

and look for 0x34 on the left side. You can also do

    objdump -S my-module.ko

to see the source code intermixed with assembly. This will help you pinpoint
the spot in the source code faster.

====

If the faulting address is low, like 0x8 or 0x34, you most likely are using
a null pointer somewhere - which may imply you have uninitialized data
(globals, e.g.).

====

If you get a general protection exception on a mov instruction, you might
have a bad non-canonical address - also may mean uninitialized data.
